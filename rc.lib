#
# rc.lib
#

# vim:filetype=sh
# shellcheck disable=1090

# Functions for rc.boot and rc.shutdown

out() { printf "\033[1;36m->\033[0;00m\033[1m $1\033[0;00m\n" ;}
error() { printf "\033[1;31m-> ERROR: \033[0;00m\033[1m $1\033[0;00m\n" ;}
welcome() { printf '\033[1;36m->\033[m\033[1m Welcome to\033[35m Carbs Linux\033[m\033[1m!\n' ;}

mnt() {
    mountpoint -q "$1" || {
        dir=$1
        shift
        mount "$@" "$dir"
    }
}

emergency_shell() {
    error "Cannot continue init due to errors above, starting emergency shell"
    error "When ready, type 'exit' to continue the boot."

    /bin/sh -l
}

parse_crypttab() {
    # This is a pure shell crypttab parser which supports
    # a subset of the format.

    # Function by Dylan Araps
    exec 3<&0

    # shellcheck disable=2086
    while read -r name dev pass opts err; do
        # Skip comments.
        [ "${name##\#*}" ] || continue

        # Break on invalid crypttab (> 5 columns).
        [ "$err" ] && break

        # Turn 'UUID=*' lines into device names.
        [ "${dev##UUID*}" ] || dev=$(blkid -l -o device -t "$dev")

        # Parse options by turning the list into a pseudo array.
        { old_ifs=$IFS; IFS=,; set -f; set +f -- $opts; IFS=$old_ifs; }

        # Create an argument list (no other way to do this in sh).
        for opt; do case $opt in
            discard)            copts="$copts --allow-discards" ;;
            readonly|read-only) copts="$copts -r" ;;
            tries=*)            copts="$copts -T ${opt##*=}" ;;
        esac; done

        # If password is 'none', '-' or empty ask for it.
        case $pass in
            none|-|"") cryptsetup luksOpen $copts "$dev" "$name" <&3 ;;
            *)         cryptsetup luksOpen $copts -d "$pass" "$dev" "$name" ;;
        esac
    done < /etc/crypttab

    exec 3>&-

    [ "$copts" ] && [ -x /bin/vgchange ] && {
        out "Activating LVM devices for dm-crypt..."
        vgchange --sysinit -a y || emergency_shell
    }
}
