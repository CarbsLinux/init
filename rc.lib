#
# rc.lib
#

# vim:filetype=sh
# shellcheck disable=1090

# Functions for rc.boot and rc.shutdown

out() { printf '\033[1;36m-> \033[m\033[1m%s\033[m\n' "$@" ;}
error() { printf '\033[1;31m!> ERROR: \033[m\033[1m%s\033[m\n' "$@" >&2 ;}
welcome() { printf '\033[1;36m->\033[m\033[1m Welcome to\033[35m %s\033[m\033[1m!\n' "Carbs $(uname -sr)" ;}

emergency_shell() {
    error "Cannot continue init due to errors above, starting emergency shell" \
    "When ready, type 'exit' to continue the boot."

    /bin/sh -l
}

parse_crypttab() {
    # This is a pure shell crypttab parser which supports
    # a subset of the format.

    # Function by Dylan Araps
    exec 3<&0

    # shellcheck disable=2086
    while read -r name dev pass opts err; do
        # Skip comments.
        [ "${name##\#*}" ] || continue

        # Break on invalid crypttab (> 5 columns).
        [ "$err" ] && break

        # Turn 'UUID=*' lines into device names.
        [ "${dev##UUID*}" ] || dev=$(blkid -l -o device -t "$dev")

        # Parse options by turning the list into a pseudo array.
        { old_ifs=$IFS; IFS=,; set -f; set +f -- $opts; IFS=$old_ifs; }

        # Create an argument list (no other way to do this in sh).
        for opt; do case $opt in
            discard)            copts="$copts --allow-discards" ;;
            readonly|read-only) copts="$copts -r" ;;
            tries=*)            copts="$copts -T ${opt##*=}" ;;
        esac; done

        # If password is 'none', '-' or empty ask for it.
        case $pass in
            none|-|"") cryptsetup luksOpen $copts "$dev" "$name" <&3 ;;
            *)         cryptsetup luksOpen $copts -d "$pass" "$dev" "$name" ;;
        esac
    done < /etc/crypttab

    exec 3>&-

    [ "$copts" ] && [ -x /bin/vgchange ] && {
        out "Activating LVM devices for dm-crypt..."
        vgchange --sysinit -a y || emergency_shell
    }
}
